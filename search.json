[{"title":"springboot自动装配","path":"/2024/03/10/springboot自动装配/","content":"1、自动装配原理我们直接来看看Spring boot的核心注解 1234567891011121314151617@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;) public @interface SpringBootApplication &#123; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;; String[] scanBasePackages() default &#123;&#125;; Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; boolean proxyBeanMethods() default true; &#125; 可以看到@SpringBootApplication主要由@SpringBootConfiguration 、@EnableAutoConfiguration和@ComponentScan。其中@SpringBootConfiguration是对@Configuration的包装，@ComponentScan用于配置包扫描路径，而@EnableAutoConfiguration则是自动装配的核心 1234567891011@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; @EnableAutoConfiguration由@AutoConfigurationPackage和@Import组成，@AutoConfigurationPackage用于指定自动装配的路径，不指定则以当前类所在路径进行扫描；@Import则用于在配置类中引入其他配置类，以将它们的配置信息合并到当前配置类中。@Import有四种用法，包括引入配置类、普通类、ImportSelector 实现类和ImportBeanDefinitionRegistrar 实现类。可以看到在@EnableAutoConfiguration通过@Import引入了AutoConfigurationImportSelector类，可以看到该类实现了ImportSelector接口，Spring在加载时会去扫描@import中引入的ImportSelector并执行ImportSelector#selectImports方法 Pasted image 20240310115831.png 因此我们来看看AutoConfigurationImportSelector.selectImports的实现 12345678@Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125; 首先检查自动装配是否开启，未开启则直接返回一个空数组。重点在于getAutoConfigurationEntry方法 1234567891011121314protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); &#125; 我们不妨来调试以下看看，新建一个springboot项目，且不额外引入任何依赖，可以发现执行getCandidateConfigurations方法后得到了若干个AutoConfiguration类的全限定名 Pasted image 20240310134909.png 这些类名是从哪里来的呢，我们可以看下getCandidateConfigurations方法的实现。从该方法打印的日志可以看出，这些类名是从META-INF&#x2F;spring.factories中读取的 1234567protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; &#125; 进入到SpringFactoriesLoader.loadFactoryNames方法中，可以看到通过loadSpringFactories方法取到了一个map，这个map中存放着所有META-INF&#x2F;spring.factories文件中的配置信息，并取org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的值进行自动装配 Pasted image 20240310160037.png spring-boot-autoconfigure下的META-INF\\spring.factories文件 Pasted image 20240310161059.png 我们再回到getAutoConfigurationEntry方法中来看这些取到的configurations，会发现这些类名中有很多我们没有引入的依赖，这些配置类也会执行吗 Pasted image 20240310151912.png 我们先继续向下执行，首先removeDuplicates方法会去除掉重复的配置项，getExclusions方法则会取到@EnableAutoConfiguration注解中exclude和excludeName属性配置的需要排除的配置项（由于我没有配置，这里数量没有变化），重点在于getConfigurationClassFilter.filter方法，可以看到在执行完该方法后，configurations中只剩下13个类名了 Pasted image 20240310163503.png 我们随意打开一个类，AopAutoConfiguration，可以看到该类是简单配置类，但打了一个@ConditionalOnProperty注解该注解派生于@Conditional，当ConfigurationClassFilter.filter执行时，会根据配置类上的@Conditional注解决定到底要不要装配该类，例如AopAutoConfiguration当spring.aop.auto设置为true或缺省时需要装配，否则不装配，类似的注解还@ConditionalOnBean（当指定的 Bean 存在时）、@ConditionalOnClass（当指定的类存在于类路径中时）、@ConditionalOnWebApplication（当应用是一个 Web 应用时）等 Pasted image 20240310140648.png 最终通过AutoConfigurationImportSelector.selectImports获取到的配置类，会再通过一些列处理，用于生成BeanDefinition 2、自己实现一个starter新起一个项目命名为spring-boot-demo-starter，pom.xml如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lzsf&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-demo-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-demo-starter&lt;/name&gt; &lt;description&gt;spring-boot-demo-starter&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;8&lt;/java.version&gt; &lt;/properties&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 创建一个DemoProperty类来映射配置文件 123456789101112131415161718192021222324252627package org.lzsf; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(&quot;org.lzsf.demo&quot;) public class DemoProperty &#123; private boolean enable; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isEnable() &#123; return enable; &#125; public void setEnable(boolean enable) &#123; this.enable = enable; &#125; &#125; 创建一个用于装配的bean 123456789101112131415161718package org.lzsf; public class DemoModule &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;&#123;name=&#x27;&quot; + getName() + &quot;&#x27;&#125;&quot;; &#125; &#125; 创建自动装配配置类DemoAutoConfiguration，并且设置为enable不为false时需要装配 12345678910111213141516171819package org.lzsf; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @EnableConfigurationProperties(DemoProperty.class) @ConditionalOnProperty(prefix = &quot;org.lzsf.demo&quot;, value = &quot;enable&quot;, havingValue = &quot;true&quot;, matchIfMissing = true) public class DemoAutoConfiguration &#123; @Bean public DemoModule demoModule(DemoProperty demoProperty) &#123; DemoModule demoModule = new DemoModule(); demoModule.setName(demoProperty.getName()); return demoModule; &#125; &#125; 编写spring.factories文件 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.lzsf.DemoAutoConfiguration 最执行maven install将该项目打包到本地仓库再创建一个springboot项目，在该项目中引入上面打好的包 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.lzsf&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-demo-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在application.properties文件中进行配置 12org.lzsf.demo.enable=true org.lzsf.demo.name=DEMO 最后在启动类中尝试取到bean demoModule 123456789@SpringBootApplication public class DemoApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class, args); System.out.println(context.getBean(&quot;demoModule&quot;)); &#125; &#125; 执行结果可以看到，demoModule已经被自动装配到容器中了 Pasted image 20240310224615.png 如果我们尝试将org.lzsf.demo.enable改为false，再执行，我们会发现执行失败无法取到该bean Pasted image 20240310224736.png","tags":["Java","SpringBoot"]},{"title":"Canal同步mysql数据至rocketMq","path":"/2023/11/18/Canal同步mysql数据至rocketMq/","content":"Canal概述在业务系统中，我们常常需要关注mysql表中某些数据的变化，当数据发生变化时，实时同步到es中，或者触发某些特定流程，因此需要一个工具提供MySQL数据变更的订阅与消费能力我们知道MySQL的binlog可以用于主从同步，在MySQL集群中，slave会向master发送同步请求，master收到请求后会返回binlog对象，slave收到响应后将binlog写入到自己中继日志relay log中，然后再重放relay log中的数据，变更自身的数据阿里的Canal会伪装成MySQL Slave向Master节点发送同步请求，并解析从Master收到的binlog对象 Canal 实践 环境：腾讯云centos7; Docker version 18.06.3-ce; 1、安装并配置Mysql在docker中拉取mysql镜像 1[root@VM-4-2-centos mysql]# docker pull mysql 拉取成功 123[root@VM-4-2-centos mysql]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql latest a3b6608898d6 3 weeks ago 596MB 在本地新建几个目录， 分别存放数据、配置和日志，用于挂载到docker容器中 123[root@VM-4-2-centos /]# mkdir usr/local/mysql/data[root@VM-4-2-centos /]# mkdir usr/local/mysql/conf[root@VM-4-2-centos /]# mkdir usr/local/mysql/log 创建配置文件开启binlog 1vim usr/local/mysql/conf/my.conf 1234567[mysqld]## 设置binlog存储目录log-bin=/var/lib.mysql/mysql-binserver-id=1binlog_format=ROW## 设置binlog过期时间，默认为0永久expire_logs_days=30 启动mysql容器并挂载目录 123456789[root@VM-4-2-centos /]# \\&gt; docker run -d \\&gt; -p 3306:3306 \\&gt; --name mysql8 \\&gt; -v /usr/local/mysql/data:/var/lib/mysql \\&gt; -v /usr/local/mysql/conf:/etc/mysql/conf.d \\&gt; -v /usr/local/mysql/log:/var/log/mysql \\&gt; -e MYSQL_ROOT_PASSWORD=LZ1234 \\&gt; mysql 参数解释 12345-d ##后台运行-p [宿主端口]:[容器端口] ##端口映射-v [宿主目录]:[容器目录] ##挂载目录--name ##为容器指定一个名字-e ##设置环境变量 查看docker当前运行的容器，可以看到mysql8已经在运行中了 123[root@VM-4-2-centos /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES22ef1762e562 mysql &quot;docker-entrypoint.s…&quot; 5 minutes ago Up 5 minutes 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql8 进入到mysql容器 12[root@VM-4-2-centos data]# docker exec -it mysql8 /bin/bashbash-4.4# mysql -u root -p 可以看到binlog已经开启了 123456mysql&gt; show variables like &#x27;log_bin&#x27;;+---------------+-------+| Variable_name | Value |+---------------+-------+| log_bin | ON |+---------------+-------+ 为Canal创建一个mysql账户并分配权限 12345678mysql&gt; CREATE USER canal IDENTIFIED BY &#x27;canal&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; GRANT SELECT, SHOW VIEW, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 创建一张表用于测试 1234567891011mysql&gt; CREATE DATABASE `test`;Query OK, 1 row affected (0.02 sec)mysql&gt; USE `test`;Database changedmysql&gt; CREATE TABLE `user` ( -&gt; `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;user id&#x27;, -&gt; `user_name` VARCHAR(256) NOT NULL COMMENT &#x27;user name&#x27;, -&gt; `password` VARCHAR(256) NOT NULL COMMENT &#x27;password&#x27;, -&gt; PRIMARY KEY(`id`) -&gt; ) ENGINE=InnoDB AUTO_INCREMENT=1 CHARSET=utf8mb4;Query OK, 0 rows affected, 1 warning (0.03 sec) 2、安装并配置rocketMq（单机）拉取rocketMq镜像 1[root@VM-4-2-centos conf]# docker pull rocketmqinc/rocketmq 创建namesrv的文件夹用以挂载 12[root@VM-4-2-centos local]# mkdir /usr/local/rocketmq/namesrv/logs[root@VM-4-2-centos local]# mkdir /usr/local/rocketmq/namesrv/store 启动namesrv 12345678[root@VM-4-2-centos local]# \\&gt; docker run -d \\&gt; -p 9876:9876 \\&gt; -v /usr/local/rocketmq/namesrv/logs:/root/logs \\&gt; -v /usr/local/rocketmq/namesrv/store:/root/store \\&gt; --name rmqNamesrv \\&gt; rocketmqinc/rocketmq \\&gt; sh mqnamesrv 查看运行中的容器可以看到容器已启动 1234[root@VM-4-2-centos local]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfdb2d77cb29f rocketmqinc/rocketmq &quot;sh mqnamesrv&quot; 9 seconds ago Up 8 seconds 10909/tcp, 0.0.0.0:9876-&gt;9876/tcp, 10911/tcp rmqNamesrv71f35f013ae1 mysql &quot;docker-entrypoint.s…&quot; 35 minutes ago Up 35 minutes 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql8 查看namesrv日志可以看到启动成功了 123[root@VM-4-2-centos local]# cat /usr/local/rocketmq/namesrv/logs/rocketmqlogs/namesrv.log... ...2023-11-19 11:16:18 INFO main - The Name Server boot success. serializeType=JSON 创建broker的文件夹及配置文件用以挂载到容器 1234[root@VM-4-2-centos local]# mkdir /usr/local/rocketmq/broker/logs[root@VM-4-2-centos local]# mkdir /usr/local/rocketmq/broker/store[root@VM-4-2-centos local]# mkdir /usr/local/rocketmq/broker/conf[root@VM-4-2-centos local]# vim /usr/local/rocketmq/broker/conf/broker.conf 12345678910111213141516171819# 所属集群名称，如果节点较多可以配置多个brokerClusterName = DefaultCluster#broker名称，master和slave使用相同的名称，表明他们的主从关系brokerName = broker-a#0表示Master，大于0表示不同的slavebrokerId = 0#表示几点做消息删除动作，默认是凌晨4点deleteWhen = 04#在磁盘上保留消息的时长，单位是小时fileReservedTime = 48#有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；brokerRole = ASYNC_MASTER#刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；flushDiskType = ASYNC_FLUSH# 设置namesrv地址namesrvAddr=***.***.***.***:9876# 设置宿主机ip地址brokerIP1=***.***.***.*** 启动broker容器 1234567891011[root@VM-4-2-centos local]# \\&gt; docker run -d \\&gt; -p 10911:10911 -p 10909:10909 \\&gt; -v /usr/local/rocketmq/broker/logs:/root/logs \\&gt; -v /usr/local/rocketmq/broker/store:/root/store \\&gt; -v /usr/local/rocketmq/broker/conf/broker.conf:/opt/rocketmq/conf/broker.conf \\&gt; --name rmqBroker \\&gt; --link rmqNamesrv:namesrv \\&gt; -e &quot;NAMESRV_ADDR=namesrv:9876&quot; \\&gt; rocketmqinc/rocketmq \\&gt; sh mqbroker -c /opt/rocketmq/conf/broker.conf 安装并启动rocketmq-console 12345678[root@VM-4-2-centos rocketmq]# docker pull styletang/rocketmq-console-ng[root@VM-4-2-centos rocketmq]# \\&gt; docker run -d \\&gt; --restart=always \\&gt; --name rocketmqConsole \\&gt; -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=***.***.***.***:9876 -Drocketmq.config.isVIPChannel=false&quot; \\&gt; -p 9090:8080 \\&gt; styletang/rocketmq-console-ng 3、配置并启动Canal下载Cancal并解压 123[root@VM-4-2-centos canal]# wget https://github.com/alibaba/canal/releases/download/canal-1.1.7/canal.deployer-1.1.7.tar.gz[root@VM-4-2-centos canal]# mkdir canal-deployer[root@VM-4-2-centos canal]# tar -zxvf canal.example-1.1.7.tar.gz -C ./canal-deployer 更改.&#x2F;canal-deployer&#x2F;conf&#x2F;canal.properties配置，将serverMode改为rocketMq 12# tcp, kafka, rocketMQ, rabbitMQ, pulsarMQcanal.serverMode = rocketMQ 更改.&#x2F;canal-deployer&#x2F;conf&#x2F;example&#x2F;instance.properties配置，其中canal.instance.mysql.slaveId不能与mysql的id相同，1.0.26版本后会自动生成，可不配置 123456789# mysql地址canal.instance.master.address=127.0.0.1:3306# mysql用户canal.instance.dbUsername=canalcanal.instance.dbPassword=canal# 需要监听的库表，默认为所有canal.instance.filter.regex=.*\\\\..*# 打开动态topic，且每个表都会发送到表名的topic中canal.mq.dynamicTopic=.*\\\\..* 启动canal 1[root@VM-4-2-centos bin]# sh /usr/local/canal/canal-deployer/bin/startup.sh 这时候我们在到rocketMq后台可以看到已经有名为test_user的topic 动态生成的topic 我们在test.user中插入一条数据 1234567891011mysql&gt; INSERT INTO `user` (`user_name`, `password`) -&gt; VALUES (&#x27;zhangsan&#x27;, &#x27;zhangsan1234&#x27;);Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT * FROM `user`;+----+-----------+--------------+| id | user_name | password |+----+-----------+--------------+| 1 | zhangsan | zhangsan1234 |+----+-----------+--------------+1 row in set (0.00 sec) mq也收到了该消息 新增消息 再尝试更新一下 123mysql&gt; UPDATE `user` SET `password` = &#x27;zhangsan2345&#x27; WHERE `id` = 1;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0 更新消息","tags":["Java","Canal","MySQL","Binlog","RocketMQ"]}]